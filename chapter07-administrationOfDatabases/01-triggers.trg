-- Adrián Navarro Gabino


-- EJERCICIO 1

-- Crear un disparador que consiga mantener actualizada la tabla transacción
-- cada vez que se modifique la tabla cuenta (se cambie el atributo balance).

CREATE TABLE CUENTA
(
    NRO_CUENTA VARCHAR2(10) PRIMARY KEY,
    BALANCE NUMBER
);

CREATE TABLE TRANSACCION
(
    NRO_CUENTA VARCHAR2(10),
    HORA_MODIFICACION VARCHAR2(5),
    ID_CLIENTE VARCHAR2(10),
    ANT_BALANCE NUMBER,
    ACT_BALANCE NUMBER,
    CONSTRAINT PK_TRANSACCION PRIMARY KEY (NRO_CUENTA, HORA_MODIFICACION)
);

CREATE OR REPLACE TRIGGER TR_CAMBIAR_BALANCE
AFTER INSERT OR UPDATE OF BALANCE ON CUENTA
FOR EACH ROW
BEGIN
    IF UPDATING THEN
        INSERT INTO TRANSACCION
        (NRO_CUENTA, HORA_MODIFICACION, ANT_BALANCE, ACT_BALANCE)
        VALUES
        (:OLD.NRO_CUENTA, TO_CHAR(SYSDATE,'HH24:MI'), :OLD.BALANCE, :NEW.BALANCE);
    ELSE
        INSERT INTO TRANSACCION
        (NRO_CUENTA, HORA_MODIFICACION, ANT_BALANCE, ACT_BALANCE)
        VALUES
        (:NEW.NRO_CUENTA, TO_CHAR(SYSDATE,'HH24:MI'), NULL, :NEW.BALANCE);
    END IF;
END;

-- EJERCICIO 2

-- Crear disparadores para conseguir que cuando se introduzca (o se modifique)
-- una distancia en kilómetros, automáticamente se introduzca también en millas
-- y viceversa. (1 Km=0.621371 millas y 1 Milla=1.609344 Km).

CREATE TABLE DISTANCIAS
(
    RUTA VARCHAR2(10) PRIMARY KEY,
    DISTANCIA_K NUMBER,
    DISTANCIA_M NUMBER
);

CREATE OR REPLACE TRIGGER TR_KMS_MILLAS
BEFORE INSERT OR UPDATE OF DISTANCIA_K, DISTANCIA_M ON DISTANCIAS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        IF :NEW.DISTANCIA_K < :NEW.DISTANCIA_M * 0.62 OR :NEW.DISTANCIA_K > :NEW.DISTANCIA_M * 0.63 THEN
            RAISE_APPLICATION_ERROR(-20101, 'LAS DISTANCIAS NO COINCIDEN');
        ELSIF :NEW.DISTANCIA_K IS NOT NULL AND :NEW.DISTANCIA_M IS NULL THEN
            :NEW.DISTANCIA_M := :NEW.DISTANCIA_K * 0.621371;
        ELSIF :NEW.DISTANCIA_K IS NULL AND :NEW.DISTANCIA_M IS NOT NULL THEN
            :NEW.DISTANCIA_K := :NEW.DISTANCIA_M * 1.609344;
        END IF;
    ELSE
        IF :OLD.DISTANCIA_K = :NEW.DISTANCIA_K THEN
            :NEW.DISTANCIA_K := :NEW.DISTANCIA_M * 1.609344;
        ELSIF :OLD.DISTANCIA_M = :NEW.DISTANCIA_M THEN
            :NEW.DISTANCIA_M := :NEW.DISTANCIA_K * 0.621371;
        ELSIF :NEW.DISTANCIA_K < :NEW.DISTANCIA_M * 0.62 OR :NEW.DISTANCIA_K > :NEW.DISTANCIA_M * 0.63 THEN
            RAISE_APPLICATION_ERROR(-20101, 'LAS DISTANCIAS NO COINCIDEN');
        END IF;
    END IF;
END;

-- EJERCICIO 3

-- Transformar el siguiente esquema relacional haciendo desaparecer las
-- claves ajenas mediante el uso de disparadores.

CREATE TABLE EMPLOYEE(
NAMEP VARCHAR2(15) NOT NULL,
INIC VARCHAR2(1),
SURNAME VARCHAR2(15) NOT NULL,
NSS VARCHAR2(9) NOT NULL,
DATEN DATE,
ADDRESS VARCHAR2(30),
SEX VARCHAR2(1),
SALARY NUMBER(10,2),
ND NUMBER NOT NULL,
PRIMARY KEY (NSS));

CREATE TABLE DEPARTAMENT(
NAMED VARCHAR2(15) NOT NULL,
NUMBERD NUMBER NOT NULL,
DATEINICGTE DATE,
PRIMARY KEY (NUMBERD));

CREATE TABLE SITE_DEPTS(
NUMBERD NUMBER NOT NULL,
SITED VARCHAR2(15) NOT NULL,
PRIMARY KEY (NUMBERD, SITED));

CREATE TABLE PROJECT(
NAMEPR VARCHAR2(15) NOT NULL,
NUMBERP NUMBER NOT NULL,
SITEPR VARCHAR2(15),
NUMD NUMBER NOT NULL,
PRIMARY KEY (NUMBERP));

CREATE TABLE WORK_IN(
NSSE VARCHAR2 (9) NOT NULL,
NUMP NUMBER NOT NULL,
HOURS NUMBER(3,1) NOT NULL,
PRIMARY KEY (NSSE, NUMP));

CREATE OR REPLACE TRIGGER TR_FK_DEPARTAMENT
BEFORE DELETE OR UPDATE OF NUMBERD ON DEPARTAMENT
FOR EACH ROW
DECLARE
     DATOS NUMBER;
BEGIN
    IF DELETING THEN
        DELETE FROM EMPLOYEE
        WHERE ND = :OLD.NUMBERD;
        
        DELETE FROM SITE_DEPTS
        WHERE NUMBERD = :OLD.NUMBERD;
        
        DELETE FROM PROJECT
        WHERE NUMD = :OLD.NUMBERD;
    ELSE
        SELECT COUNT(*)
        INTO DATOS
        FROM EMPLOYEE
        WHERE ND = :OLD.NUMBERD;
        
        IF DATOS <> 0 AND :NEW.NUMBERD <> :OLD.NUMBERD THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK: HIJOS ENCONTRADOS');
        END IF;
        
        SELECT COUNT(*)
        INTO DATOS
        FROM SITE_DEPTS
        WHERE NUMBERD = :OLD.NUMBERD;
        
        IF DATOS <> 0 AND :NEW.NUMBERD <> :OLD.NUMBERD THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
        END IF;
        
        SELECT COUNT(*)
        INTO DATOS
        FROM PROJECT
        WHERE NUMD = :OLD.NUMBERD;
        
        IF DATOS <> 0 AND :NEW.NUMBERD <> :OLD.NUMBERD THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
        END IF;
    END IF;
END;

CREATE OR REPLACE TRIGGER TR_FK_WORK_IN
BEFORE INSERT OR UPDATE OF NSSE, NUMP ON WORK_IN
FOR EACH ROW
DECLARE
     DATOS1 NUMBER;
     DATOS2 NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO DATOS1
    FROM EMPLOYEE
    WHERE NSS = :NEW.NSSE;
    
    SELECT COUNT(*)
    INTO DATOS2
    FROM PROJECT
    WHERE NUMD = :NEW.NUMP;
        
    IF DATOS1 = 0 OR DATOS2 = 0 THEN
        RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
    END IF;
END;

CREATE OR REPLACE TRIGGER TR_FK_EMPLOYEE
BEFORE INSERT OR DELETE OR UPDATE OF ND, NSS ON EMPLOYEE
FOR EACH ROW
DECLARE
    DATOS1 NUMBER;
    DATOS2 NUMBER;
BEGIN
    IF INSERTING THEN
        SELECT COUNT(*)
        INTO DATOS1
        FROM DEPARTAMENT
        WHERE NUMBERD = :NEW.ND;
        
        IF DATOS1 = 0 THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
        END IF;
    ELSIF DELETING THEN
        DELETE FROM WORK_IN
        WHERE NSSE = :OLD.NSS;
    ELSE
        SELECT COUNT(*)
        INTO DATOS1
        FROM DEPARTAMENT
        WHERE NUMBERD = :NEW.ND;
        
        SELECT COUNT(*)
        INTO DATOS2
        FROM WORK_IN
        WHERE NUMP = :NEW.ND;
        
        IF DATOS1 = 0 OR (DATOS2 <> 0 AND :NEW.NSS <> :OLD.NSS) THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
        END IF;
    END IF;
END;

CREATE OR REPLACE TRIGGER TR_FK_SITE_DEPTS
BEFORE INSERT OR UPDATE OF NUMBERD ON SITE_DEPTS
FOR EACH ROW
DECLARE
    DATOS NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO DATOS
    FROM DEPARTAMENT
    WHERE NUMBERD = :NEW.NUMBERD;
        
    IF DATOS = 0 THEN
        RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
    END IF;
END;

CREATE OR REPLACE TRIGGER TR_FK_PROJECT
BEFORE INSERT OR DELETE OR UPDATE OF NUMD ON PROJECT
FOR EACH ROW
DECLARE
    DATOS1 NUMBER;
    DATOS2 NUMBER;
BEGIN
    IF INSERTING THEN
        SELECT COUNT(*)
        INTO DATOS1
        FROM DEPARTAMENT
        WHERE NUMBERD = :NEW.NUMD;
        
        IF DATOS1 = 0 THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
        END IF;
    ELSIF DELETING THEN
        DELETE FROM WORK_IN
        WHERE NUMP = :OLD.NUMD;
    ELSE
        SELECT COUNT(*)
        INTO DATOS1
        FROM DEPARTAMENT
        WHERE NUMBERD = :NEW.NUMD;
        
        SELECT COUNT(*)
        INTO DATOS2
        FROM WORK_IN
        WHERE NUMP = :NEW.NUMD;
        
        IF DATOS1 = 0 OR (DATOS2 <> 0 AND :NEW.NUMD <> :OLD.NUMD) THEN
            RAISE_APPLICATION_ERROR(-20100, 'ERROR FK');
        END IF;
    END IF;
END;

-- EJERCICIO 4

-- Diseñar un disparador que al insertar un nuevo empleado, automáticamente
-- quede actualizado el presupuesto total del departamento al que el empleado
-- pertenece, añadiéndole el salario asignado al nuevo empleado.

CREATE TABLE EMPLEADO
(
    NSS NUMBER PRIMARY KEY,
    NOMBRE VARCHAR2(10),
    SALARIO NUMBER,
    NUM_DEP VARCHAR2(10)
);

CREATE TABLE DEPARTAMENTO
(
    NUM_DEP VARCHAR2(10) PRIMARY KEY,
    NOMBRE VARCHAR2(10),
    PRESUPUESTO NUMBER
);

CREATE OR REPLACE TRIGGER TR_PRESUPUESTO
AFTER INSERT ON EMPLEADO
FOR EACH ROW
BEGIN
    UPDATE DEPARTAMENTO
    SET PRESUPUESTO = PRESUPUESTO + :NEW.SALARIO
    WHERE NUM_DEP = :NEW.NUM_DEP;
END;

-- Diseñar un disparador que al modificar el salario de un empleado,
-- automáticamente quede actualizado el presupuesto total del departamento al que
-- el empleado pertenece, en función del nuevo salario asignado al empleado.

CREATE OR REPLACE TRIGGER TR_PRESUPUESTO_CAMBIAR_SALARIO
AFTER UPDATE OF SALARIO ON EMPLEADO
FOR EACH ROW
BEGIN
    IF :NEW.NUM_DEP = :OLD.NUM_DEP THEN
        UPDATE DEPARTAMENTO
        SET PRESUPUESTO = PRESUPUESTO + :NEW.SALARIO - :OLD.SALARIO
        WHERE NUM_DEP = :NEW.NUM_DEP;
    ELSE
        UPDATE DEPARTAMENTO
        SET PRESUPUESTO = PRESUPUESTO - :OLD.SALARIO
        WHERE NUM_DEP = :OLD.NUM_DEP;
        
        UPDATE DEPARTAMENTO
        SET PRESUPUESTO = PRESUPUESTO + :NEW.SALARIO
        WHERE NUM_DEP = :NEW.NUM_DEP;
    END IF;
END;

-- EJERCICIO 5

-- Si tenemos una serie de disparadores cuyo evento es el mismo y cuya acción
-- es la inserción de filas en una tabla, pero de forma que estén definidos de la
-- siguiente manera:
-- 1 a nivel de orden con temporalidad BEFORE
-- 1 a nivel de orden con temporalidad AFTER
-- 1 a nivel de fila con temporalidad BEFORE
-- 1 a nivel de fila con temporalidad AFTER
-- Determinar, mediante un ejemplo, el orden en que se irán activando dichos
-- disparadores mostrando como va variando el contenido de la tabla en la que se
-- inserta.

CREATE OR REPLACE TRIGGER TR_PRIMERO
BEFORE DELETE ON CUENTA
BEGIN
    DBMS_OUTPUT.PUT_LINE('1 a nivel de orden con temporalidad BEFORE');
END;

CREATE OR REPLACE TRIGGER TR_CUARTO
AFTER DELETE ON CUENTA
BEGIN
    DBMS_OUTPUT.PUT_LINE('1 a nivel de orden con temporalidad AFTER');
END;

CREATE OR REPLACE TRIGGER TR_SEGUNDO
BEFORE DELETE ON CUENTA
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('1 a nivel de fila con temporalidad BEFORE');
END;

CREATE OR REPLACE TRIGGER TR_TERCERO
AFTER DELETE ON CUENTA
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('1 a nivel de fila con temporalidad AFTER');
END;

INSERT INTO CUENTA
(NRO_CUENTA)
VALUES
('AAAAAA');

DELETE FROM CUENTA
WHERE NRO_CUENTA = 'AAAAAA';